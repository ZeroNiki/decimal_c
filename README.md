# Decimal
## Usage
```sh
make
```
- Static lib

```sh
make full-check
```
- Clang, cppcheck, valgrind

```sh
make test
```
- Test func

```sh
make gcov_report
```
- Gcov report

```sh
make clean
```
- Clean

## База
- Как хранить десятичное число в uint32_t bits[4]
- Как представлять знак и scale.
- Как конвертировать типы
- Продумать алгоритм сложения

## Представления числа
`bits[0]`, `bits[1]`, `bits[2]` — 96-битное целое число, представляющее мантиссу.
`bits[3]` - служебные биты:
    - Бит 31 (самый старший знак) = знак (`0` = `+`, `1` = `-`)
    - Биты 16-23 = scale
    - Остальные биты `bits[3]` должны быть нулевыми.

### Как хранить число?
123 - 0000007B - 0 - 0 (`+`)

| число   | Бит      | scale | sign    |
|---------|----------|-------|---------|
| 123     | 0000007B | 0     | 0 (`+`) |
| 123.24  | 00003039 | 2     | 0 (`+`) |
| -123.4  | 000186A5 | 1     | 1 (`-`) |

`123`:
```
bits[2] = 00000000
bits[1] = 00000000
bits[0] = 0000007B
bits[3] = 00000000  (scale = 0, знак +)
```

`123.24` (`12324`):
```
bits[2] = 00000000
bits[1] = 00000000
bits[0] = 00003039  (12345 в 16-ричной системе)
bits[3] = 00020000  (scale = 2, знак +)
```

`-9876.5` (`98765`):
```
bits[2] = 00000000
bits[1] = 00000000
bits[0] = 000186A5  (98765 в 16-ричной системе)
bits[3] = 80010000  (scale = 1, знак -)
```

### Как представлять большие числа?
Так как у нас есть 96 бит (3 × uint32_t), мы можем хранить числа до:

> (2^96) - 1 ≈ 79 228 162 514 264 337 593 543 950 335
То есть числа от -79 квинтиллионов до +79 квинтиллионов.

Пример хранения большого числа 79 228 162 514 264 337 593 543 950 335 (0xFFFFFFFFFFFFFFFFFFFFFFFF):
```
bits[2] = FFFFFFFF
bits[1] = FFFFFFFF
bits[0] = FFFFFFFF
bits[3] = 00000000  (scale = 0, знак +)
```

Здесь bits[3] = 0, так как число положительное и без дробной части.

## Как работает scale
## Конвертация
## Алгоритм для сложения
